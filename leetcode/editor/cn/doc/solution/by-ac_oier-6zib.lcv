## 模拟

根据题目给定的移动规则可知，机器人总是在外圈移动（共上下左右四条），而移动方向分为四类：

![image.png](https://pic.leetcode-cn.com/1649906046-cdlyAL-image.png)

当行走步数为 $mod = 2 * (w - 1) + 2 * (h - 1)$ 的整数倍时，会回到起始位置，因此我们可以通过维护一个变量 `loc` 来记录行走的总步数，并且每次将 `loc` 对 `mod` 进行取模来得到有效步数。

在回答 `getPos` 和 `getDir` 询问时，根据当前 `loc` 进行分情况讨论（见注释）。

另外还有一个小细节：根据题意，如果当前处于 $(0, 0)$ 位置，并且没有移动过，方向为 `East`，若移动过，方向则为 `South`，这可以通过一个变量 `moved` 来进行特判处理。

代码：

* []

```Java
class Robot {
    String[] ss = new String[]{"East", "North", "West", "South"};
    int w, h, loc; // loc: 有效（取模后）移动步数
    boolean moved; // 记录是否经过移动，用于特判 (0,0) 的方向
    public Robot(int width, int height) {
        w = width; h = height;
    }
    public void step(int num) {
        moved = true;
        loc += num;
        loc %= 2 * (w - 1) + 2 * (h - 1);
    }
    public int[] getPos() {
        int[] info = move();
        return new int[]{info[0], info[1]};
    }
    public String getDir() {
        int[] info = move();
        int x = info[0], y = info[1], dir = info[2];
        // 特殊处理当前在 (0,0) 的情况，当未移动过方向为 East，移动过方向为 South
        if (x == 0 && y == 0) return moved ? ss[3] : ss[0];
        return ss[dir];
    }
    int[] move() {
        if (loc <= w - 1) {
            // 当移动步数范围在 [0,w-1] 时，所在位置为外圈的下方，方向为 East
            return new int[]{loc, 0, 0};
        } else if (loc <= (w - 1) + (h - 1)) {
            // 当移动步数范围在 [w,(w-1)+(h-1)] 时，所在位置为外圈的右方，方向为 North
            return new int[]{w - 1, loc - (w - 1), 1};
        } else if (loc <= 2 * (w - 1) + (h - 1)) {
            // 当移动步数范围在 [(w-1)+(h-1)+1,2*(w-1)+(h-1)] 时，所在位置为外圈的上方，方向为 West
            return new int[]{(w - 1) - (loc - ((w - 1) + (h - 1))), h - 1, 2};
        } else {
            // 当移动步数范围在 [2*(w-1)+(h-1)+1,2*(w-1)+2*(h-1)] 时，所在位置为外圈的左方，方向为 South
            return new int[]{0, (h - 1) - (loc - (2 * (w - 1) + (h - 1))), 3};
        }
    }
}
```

* 时间复杂度：$O(1)$
* 空间复杂度：$O(1)$

---

## 最后

**如果有帮助到你，请给题解点个赞和收藏，让更多的人看到 ~ ("▔□▔)/**

也欢迎你 [关注我](https://oscimg.oschina.net/oscnet/up-19688dc1af05cf8bdea43b2a863038ab9e5.png) 和 加入我们的[「组队打卡」](https://leetcode-cn.com/u/ac_oier/)小群 ，提供写「证明」&「思路」的高质量题解。

所有题解已经加入 [刷题指南](https://github.com/SharingSource/LogicStack-LeetCode/wiki)，欢迎 star 哦 ~
